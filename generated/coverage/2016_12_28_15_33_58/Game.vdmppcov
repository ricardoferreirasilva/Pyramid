class Game
-- Pyramid has 28 cards.
instance variables
		private deck: seq of nat;
		private workingDeck: seq of nat;
		-- The Stock: The facedown pile on the bottom left. It is used to draw cards from and put on the Waste.
		private stock: seq of nat;
		-- The Waste: The faceup pile next to the Stock. Cards on the Waste can be matched to cards in the Pyramid to get rid of the Pyramid cards.
		private waste: seq of nat;
		-- private cardDeck: seq of Card;
		
		public pyramid: seq of seq of nat;
		inv len deck = 52;
operations
    -- create g := new Game();
		public Game: () ==> Game
		Game() == 
		(
			pyramid := [];
			deck := [1,2,3,4,5,6,7,8,9,10,
			11,12,13,14,15,16,17,18,19,20,
			21,22,23,24,25,26,27,28,29,30,
			31,32,33,34,35,36,37,38,39,40,
			41,42,43,44,45,46,47,48,49,50,
			51,52];
			shuffle();
			
			-- cardDeck := [];
    	-- for counter = 1 to len deck do
    	-- (
    	-- 	dcl c : Card;
    	--	c := new Card(counter,nil,nil);
    	-- 	cardDeck := cardDeck ^ [c];				
			-- );
			IO`print("Game started.\n");
			IO`print("Deck shuffled.\n");
			createPyramid();
			return self;
			
		);

    
    -- print g.shuffle();
    public shuffle: () ==> ()
    shuffle() == (
    	dcl index  : nat;
    	dcl x : nat;
    	for counter = 1 to len deck do
    	(
    			index  := MATH`rand(52) + 1;
    			if index = 53 then index := 52;
    			x := deck (counter);
    			deck (counter) := deck (index);
    			deck (index) := x;
 					
			);
    );
    
		public createPyramid: () ==> ()
		createPyramid() == (
			workingDeck := deck;
			for i = 1 to 7 do
			(
					dcl s : seq of nat := [];
					for i2 = 1 to i do
					(
							s := s ^ [hd workingDeck];
							workingDeck := tl workingDeck;
					);
					pyramid := pyramid ^ [s];
			);	
		);
functions

traces
-- TODO Define Combinatorial Test Traces here
end Game